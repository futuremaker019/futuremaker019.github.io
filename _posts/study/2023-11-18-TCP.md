---
category: [Network]
tags: [프로토콜, study]
---

### TCP란

- Transmission Control Protocal의 약자로 메일이나 파일 전송, 웹브라우저 등 데이터 전송시 신뢰성을 요구하는 애플리케이션에서 사용한다. 
- TCP는 애플리케이션 데이터를 송신하기 전에 TCP 커넥션이라는 논리적인 통신로를 만들어 통신 환경을 정비한다.
- 송신 파이프, 수신 파이프를 이용해 송신 전용, 수신 전용으로 사용하며 데이터를 보냈는지 받았는지 확인하며 통신한다.

### 3 way handshake


<img data-action="zoom" src='{{"/assets/images/post/3-way.png" | relative_url}}' alt='absolute' width="500"/>

TCP에서의 전이 상태 중 접속 시작 단계의 과정이다. 

1. 3 way handshake 시작 전 클라이언트는 `CLOSED`, 서버는 `LISTEN` 상태이다.
2. 클라이언트는 `SYN 패킷`을 송신하고, 오픈 처리에 들어간다. 이 처리에 따라 클라이언트는 `SYN-SENT` 상태로 이동하고, 계속해서 `SYN/ACK` 패킷을 기다린다.
3. `SYN 패킷`을 받아들인 서버는 패시브 오픈 처리에 들어간다. `SYN` 플래그와 `ACK` 플래그를 `1`로 설정한 `SYN/ACK 패킷`을 반환하고 `SYN-RECEIVED` 상태로 이동한다.
4. `SYN/ACK 패킷`을 받아들인 클라이언트는 `ACK 플래그`를 `1`로 설정한 `ACK 패킷`을 반환하고, `ESTABLISHED` 상태로 이동한다. `ESTABLISHED`는 커넥션이 완료된 상태이다. 이 상태가 되면 처음으로 실제 애플레케이션 데이터를 송수신할 수 있게 된다.
5. `ACK 패킷`을 받아들인 서버는 `ESTABLISHED 상태`로 이동한다. 이 상태가 되면 처음으로 실제 애플리케이션 데이터를 송수신할 수 있게 된다.

---

3 way handshake가 완료되면 실제 애플리케이션 데이터의 교환이 일어나는데 TCP는 애플리케이션 데이터 전송의 신뢰성을 확보하기 위해 `흐름제어`, `혼잡제어`, `재전송 제어` 라는 3가지 제어를 잘 조합해 가며 전송한다.

### TCP 빠른 재전송이란

제전송 제어는 패킷 유실이 발생했을 때 수행하는 패킷 재전송 기능이다. TCP는 ACK 패킷을 통해 패킷 유실을 감지하고, 패킷을 재전송한다.

수신 측 단말은 받은 TCP 세그먼트의 번호가 일정하지 않으면 패킷 유실이 발생했다고 판단하며 확인 응답이 같은 ACK 패킷을 연속해서 송출한다. 이 ACK 패킷을 `중복 ACK`라 부른다.

송신 측 단말은 일정 수 이상 중복 ACK를 받으면 대상이 되는 TCP 세그먼트를 재전송한다. 중복 ACK를 트리거로 하는 재전송 제어를 `Fast Retransmit(고속 재전송)`이라 부른다.

### Congestion control 이란

혼잡제 제어는 송신 측 단말이 수행하는 흐름양 조정이다. 혼잡이란 네트워크의 복잡한 상태를 의미하며, 일시적으로 많은 트래픽이 몰리면서 네트워크상에 패킷이 갑자기 혼잡하게 되기 떄문이다. 

TCP는 대량의 송신 패킷에 의해 네트워크가 혼잡하지 않도록 `혼잡 제어 알고리즘` 이용하여 패킷 송신 수를 제어한다. 이 패킷 송신 수를 `혼잡 윈도우`라 부른다. 혼잡 제어 알고리즘은 혼잡하면 혼잡 윈도우를 줄이고 혼잡하지 않으면 윈도우를 늘립니다.

### Flow control 이란

`흐름제어(Flow control)` 은 수신 측 단말이 수행하는 흐름양 조정이다. 수신 측 단말은 윈도우 크기 필드를 사용해 자신이 받을 수 있는 데이터양을 알린다. 송신 측 단말은 윈도우 크기 이내에는 확인 응답을 기다리지 않고 계속 TCP 세그먼트를 보내지만, 그 이상의 데이터는 보내지 않는다. 그렇게 함으로 써 수신 측 단말이 받아들이지 못하는 일이 없도록 하면서, 가능한 많은 데이터를 송신한다. 이런 일련의 동작을 `슬라이딩 윈도우` 라고 부른다.

### 4 way handshake

<img data-action="zoom" src='{{"/assets/images/post/4-way.png" | relative_url}}' alt='absolute' width="500"/>

애플리케이션 데이터의 교환을 마치면 커넥션 종료 처리를 한다. 커넥션의 시작은 클라이언트의 SYN 으로부터 시작하지만 클로즈는 클라이언트, 서버 관계없이 먼저 `FIN`[^1] 을 송출해서 커넥션을 종료하려는 측의 처리를 `액티브 클로즈`, 그것을 받는 측의 처리를 `패시브 클로즈`라 부른다.

#### 동작과정

1. 클라이언트는 데이터 교환을 마치고, 액티브 클로즈 처리를 실시한다. FIN 플래그와 ACK 플래그를 `1`로 한 `FIN/ACK 패킷`을 송신한다. 그리고 `FIN-WAIT1` 상태로 이동한다.
2. FIN/ACK 패킷을 받은 서버는 패시브 클로즈 처리를 시작한다. ACK 패킷을 송신하고, 애플리케이션으로부터 클로즈 요청을 기다리는 `CLOSE-WAIT` 상태로 이동한다.
3. ACK 를 받은 클라이언트는 서버로부터 FIN/ACK 패킷을 기다리는 FIN-WAIT2 상태로 이동한다. 
4. 서버는 FIN/ACK 를 송신하고 자신이 송신한 FIN/ACK 패킷에 대한 ACK 패킷(클로즈 처리에 대한 최후 ACK)를 기다리는 `LAST-ACK` 단계로 이동한다.
5. FIN/ACK를 받은 클라이언트는 ACK 패킷을 반송하고 `TIME_WAIT` 상태로 이동한다.
6. ACK 패킷을 받은 서버는 `CLOSED` 상태로 이동하고, 커넥션을 삭제한다. 이와 함께, 이 커넥션에 확보하고 있던 자원을 모두 해제한다. 이것을 `패시브 클로즈`를 종료한다.
7. `TIME-WAIT`에 대기중인 클라이언트는 `CLOSED` 상태로 이동해, 커넥션을 삭제한다. 이것으로 `액티브 클로즈`를 종료한다.



출처
- 그림으로 공부하는 TCP/IP 구조(제이펍 출판)
- [https://bangu4.tistory.com/74](https://bangu4.tistory.com/74)

---

[^1]: FIN 패킷이라고 하면 FIN 플래그가 '1'인 TCP 세그먼트라고한다. FIN 플래그는 '더이상 교환할 데이터가 없습니다.' 를 의미하는 플래그로, 상위 애플리케이션의 동작에 맞춘 형태로 부여한다.
